### Replace your API to Firebase Database

アプリのロジックとデータベースを疎結合にしたいという話

- 「ビジネスロジックはModelに置くべき」と言うが、開発者によって理解や意見がバラバラで統一的な実装ができない
- 度重なる仕様変更や複雑な仕様に対応するためにViewControllerや特定のModelが肥大化し、ビジネスロジックの本質を見失う
- MVC,MVP,MVVMだけで考えると、どこかのレイヤが複数の責務を持つことになり依存度の高い複雑なコードが生まれてしまう

##### MVVMパターン
- PresentationとDomainの分離を目的としたパターン
  - プレゼンテーション層(ユーザーインターフェース)とその他の機能をうまく分ける
良い
- プレゼンテーションロジックとメインロジックが分離されていると理解しやすい
- 同じ基本プログラムを、重複コードなしに、複数のプレゼンテーションに対応させることができる
- ユーザーインターフェイスはテストがしにくいため、それを分離することにより、テスト可能なロジック部分に集中できる
- スクリプト用のAPIやサービスとして外部化するためのAPIを楽に追加できる（選択可能なプレゼンテーション部分で見かける）
- プレゼンテーション部分のコードは、ドメイン部分のコードと違ったスキルと知識が必要

不足
- モデルの設計指針は示されない
- プレゼンテーションとそれ以外をどう分けるかの指針のみ。全体設計は決まらない。


##### Clean Architecture

Clean Architecture は、Layered Architecture や その派生であるHexagonal Architectureなど、
様々な似通ったアーキテクチャパターンを総合するためのコンセプトである。
ドメイン駆動開発（DDD）やユースケース駆動開発（UCDD）を意識して、ビジネスロジックをUIやFrameworkから引き離し、
それぞれの層毎に役割と責任を分離したArchitecture
重要なのは層同士の依存の方向性に関するコンセプトである、ということ。
そして、そのコンセプトは、
「技術的な詳細やプラットフォームやユーザーインターフェイスに近い"外側"のレイヤーは、
アプリケーションの挙動やドメイン設計を実現する"内側"のレイヤーに依存していいが、
逆の方向の依存はしてはいけない」
というコンセプトです。
これを守ることでアプリケーションのテスタビリティや変更容易性を担保できる。

- 依存性が一方向になるというコンンセプトがclean architecture
- ソフトウェアをレイヤーで分離することで、構造の理解がしやすくなる
- 大きく分けるとプレゼンテーション層、ドメイン層、データ層に分けられる
- ビジネスロジックはドメイン層へ、データストアへのアクセス、技術的関心事はデータ層に定義する
- 技術的関心事とは、例えば、データベースがあげられる。データベースには色々な種類があり、またモックに差し替えられるようにして
  テストを容易にすることが望ましい

Rule of Clean Architecture by Uncle Bob
- フレームワークとは独立したアーキテクチャは、ライブラリに依存しません。これにより、システムを限られた制約に縛らずにツールとして使用することができます。
- テスト可能。ビジネスルールは、UI、データベース、Webサーバー、またはその他の外部要素なしでテストできます。
- UIとは独立しています。 UIは、システムの残りの部分を変更することなく、簡単に変更できます。たとえば、ビジネスルールを変更することなく、Web UIをコンソールUIに置き換えることができます。
- データベースとは独立しています。 OracleやSQL Server、Mongo、BigTable、CouchDBなどを交換することができます。ビジネスルールはデータベースにバインドされていません。
- 任意の外部機関の非依存。事実、ビジネスルールは外界について何も知らないだけです。




### Clean Architectureを使うことのメリット
#### ビジネスロジックが明確になる
- 特定のClassにロジックが盛り込まれFatになり、他の役割との依存性が高くなる事態を防ぐ
#### フレームワークに依存しない
- Clean Architectureは特定のフレームワークやライブラリに依存しないです
#### UIに依存しない
- ビジネスロジックを変えずにUIのみ変更することができる
#### Data Storeに依存しない
- データ連携先がサーバでも、端末内のDBでもビジネスロジックに影響が無い
- ビジネスロジックは、データの保存先や取得先を知らないくて良い
#### テストの容易性
- 全ての層でテストが導入しやすい

### Clean Architectureを使うことのデメリット
- コード量が多い
- 役割毎に層が多くなるため、必然的にコード量が多くなります
- プロトタイプや短期開発アプリケーションには向かないと思います

Firebase Realtime Databaseを使う場合、DatalayerのDataStore部分を簡単に差し替え可能な状態にしておくことが望ましい設計になりそう
Interfaceを挟んでアクセスするようにしておくと副作用をモックで差し替えられる

### それぞれのレイヤーについて

#### Presentation layer
- UIの表示やイベントのハンドリングを行います、ビジネスロジック処理はしません
#### View (ViewController)
- 画面表示やユーザのタッチイベントなどのイベントをPresenterに通知する
- Presenterから受けたModelのデータやステータスによりViewの表示を切り替える
#### Presenter
- Viewからイベントを受け取り、必要があればイベントに応じたUseCaseを実行する
- UseCaseから受け取ったデータをViewへ渡す
- Viewがどうなっているか知らない
#### Domain layer
- アプリケーション依存のビジネスロジックはこのレイヤが担当します
#### UseCase
- ユースケースに必要なロジック処理を記述する
- どのデータをどのように取得するかここで実装する
- UIには直接関与しない(View,ViewControllerから直接参照されない)
#### Translater
- UseCaseで取得したEntityをPresentation層で使用するModelへ変換する
- Viewで使用するために最適化したModelの作成を行う
#### Repository
- UseCaseで取得したいデータのCRUD相当のI/Fを記述する
- データ取得に必要なDataStoreへデータ処理のリクエストを行う
- Repositoryは、データを扱うI/Fを定義するがどうやってデータを扱うか知らない
- Domain層として記述しましたが、実態としてはDomain層とData層のI/Fです
#### Data layer
- 通信やデータ管理のロジックはこのレイヤが担当します
- DataStore
- データを実際に取得更新する処理を記述する
- サーバからデータを取得するか、DBやキャッシュのデータを使用するかどうかもここで判断する
- API通信、Realm、CoreData等を扱う実装に相当
- 複数のDataStoreを扱う場合はFactoryパターンを用いてRepositoryがData種別を意識しない設計にする
#### Entity
- DataStoreで扱うことができるデータの静的なモデル
- Entity自身を直接操作することはせず、Value objectとして使用する
- EntityはPresentation層では使用されない

